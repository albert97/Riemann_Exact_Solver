/*-----------------------------------------------------*/
/*                                                     */
/*               EXACT REIMANN SOLVER                  */
/*               FOR EULER'S EQUATION                  */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*                                                     */
/*-----------------------------------------------------*/






#include <vector>
#include <random>
#include <iostream>
#include <string>
#include <fstream>
#include <regex>
#include <zconf.h>
#include <iostream>
#include <vector>
#include <random>
#include <cmath>

using namespace std;



/* --------------- set up the parameters --------------- */

int N = 400; // number of cells
double L = 1.0;   // domain length
double CFL = 0.9;
double tStop =0.25;
double x0 = 0.5;
double gam=1.4;           // advenction velocity
double DL= 1.0;
double UL= 0.0;
double PL= 1.0;
double DR= 0.125;
double UR= 0.0;
double PR= 0.1;
double w= 0;
double Tolerance = 10.0e-6;


//test 2
/*
int N = 128; // number of cells
double L = 1.0;   // domain length
double CFL = 0.9;
double tStop = 0.15;
double x0 = 0.5;
double gam=1.4;           // advenction velocity
double DL= 1.0;
double UL= -2.0;
double PL= 0.4;
double DR= 1.0;
double UR= 2.0;
double PR= 0.4;
double w= 0.0;
double Tolerance = 10.0e-6;
*/
//test 3
/*
int N = 128; // number of cells
double L = 1.0;   // domain length
double CFL = 0.9;
double tStop = 0.005;
double x0 = 0.5;
double gam=1.4;           // advenction velocity
double DL= 1.0;
double UL= 0;
double PL= 1000.0;
double DR= 1.0;
double UR= 0.0;
double PR= 0.01;
double w= 0.0;
double Tolerance = 10.0e-6;
*/

// Test 4

/*
int N = 64; // number of cells
double L = 1.0;   // domain length
double CFL = 0.9;
double tStop = 0.020;
double x0 = 0.5;
double gam=1.4;           // advenction velocity
double DL= 1.0;
double UL= 0.0;
double PL= 0.01;
double DR= 1.0;
double UR= 0.0;
double PR= 100;
double w= 0.0;
double Tolerance = 10.0e-6;
*/
// Test 5
/*
int N = 64; // number of cells
double L = 1.0;   // domain length
double CFL = 0.9;
double tStop = 0.035;
double x0 = 0.5;
double gam=1.4;           // advenction velocity
double DL= 5.99924;
double UL= 19.5975;
double PL= 460.894;
double DR= 5.99242;
double UR= -6.19633;
double PR= 46.0950;
double w= 0.0;
double Tolerance = 10.0e-6;
*/

/* --------------- Compute Gamma related constants --------------- */

double G1 = (gam - 1.0)/(2.0 * gam);
double G2 = (gam + 1.0)/(2.0 * gam);
double G3 = 2.0 * gam/(gam - 1.0);
double G4 = 2.0/(gam - 1.0);
double G5 = 2.0/(gam + 1.0);
double G6 = (gam - 1.0)/(gam + 1.0);
double G7 = (gam - 1.0)/2.0;
double G8 = gam - 1.0;


/* ------------------- Calculate Sound Speed  -------------------- */



double sound_speed (double pressure, double rho) {


    return sqrt(gam * (pressure / rho));


}

/*------------------------Time step Calculation----------------------*/

double dt_func( double dx,  double *speed_extend, double *pressure_extend, double *density_extend){

    double a;
    double dt;

    double cmax = 0, ctemp;

    //Finding max wave speed

    /* ??????? i am confused if it should be N+3 rather than N+2 ????????*/
    for (int i=1; i<N+3;i++){

        a = sound_speed(pressure_extend[i], density_extend[i]);

        ctemp = speed_extend[i] + a ;

        if (cmax<ctemp){

            cmax =ctemp;

        }

    }

    //Determine the value for dt

    dt = CFL * (dx/cmax);

    return dt;

}


/* ---------------- The pressure positivity condition is tested for -------------- */

void vaccum_test( double G4, double CL, double CR, double UL, double UR ){

    if (G4 * ( CL + CR ) <= ( UR - UL )){

        cout<<"Vaccum is generated by the data"<<endl;
        cerr<<"Prgramme stops "<<endl;
    }

}

/* --------------- Pressure initial guess --------------- */

double P_M(double DR, double DL, double UR, double UL, double PL, double PR, double CL, double CR){

    double PM;
    double QUSER = 2.0;
    double CUP  = 0.25 * ( DL + DR ) * ( CL + CR );
    double PPV  = 0.5 * ( PL + PR ) + 0.5 * ( UL - UR ) * CUP;
    PPV = max(0.0, PPV);
    double PMIN = min ( PL,  PR );
    double PMAX = max( PL,  PR );
    double QMAX = PMAX/PMIN;

    if (QMAX <= QUSER && PMIN <= PPV && PPV <= PMAX){

        //Select PVRS Riemann Solver
        PM = PPV;

    }
    else{

        if (PPV < PMIN){

            //Select Two_Shock Riemann Solver

            double PQ  = pow((PL/PR), G1);
            double UM  = (PQ*UL/CL + UR/CR + G4*(PQ - 1.0))/(PQ/CL + 1.0/CR);
            double PTL = 1.0 + G7*(UL - UM)/CL;
            double PTR = 1.0 + G7*(UM - UR)/CR;
            PM  = 0.5*(pow((PL*PTL), G3 ) + pow((PR*PTR), G3));
        }
        else{

            //Select Two_Shock Riemann Solver with PVRS as estimate
            double GEL = sqrt((G5/DL)/(G6*PL + PPV));
            double GER = sqrt((G5/DR)/(G6*PR + PPV));
            PM  = (GEL*PL + GER*PR - (UR - UL))/(GEL + GER);

        }
    }

    return PM;

}



/* --------------- Exact Solution for pressure and velocity in star region is found --------------- */

// Solving f(P, WL, WR ) = fL ( P, WL ) + fR ( P, WR ) + UR - UL =0

double ConstA_Func(double gam, double D){

    return 2.0 / ((gam+1)*D);

}

double ConstB_Func(double gam, double P){

    return (gam - 1) * P / (gam+1);

}

void Pressure_star(double &F, double &FD, double DK, double PK, double CK, double P_Guess ) {

    //Shock Wave

    if (P_Guess > PK) {

        double QRT = sqrt(ConstA_Func(gam, DK) / (ConstB_Func(gam, PK) + P_Guess));

        F = (P_Guess - PK) * QRT;

        //FL = ( P_Guess - PL) * pow(( ConstA_Func( gam, DL ))/(P_Guess + ConstB_Func(gam, PL)), 0.5);

        FD = (1.0 - 0.5 * (P_Guess - PK) / (ConstB_Func(gam, PK) + P_Guess)) * QRT;
    }
    //Rarefraction Wave

    else {

        double PRAT = P_Guess / PK;

        F = G4 * CK * (pow(PRAT, G1) - 1.0);
        // FL = ((2 * CL)/(gam - 1)) * (pow( P_Guess/PL, (gam-1)/(2 * gam)) - 1);

        FD = (1.0 / (DK * CK)) * pow(PRAT, -G2);

    }

}


/*--------------------------Calculate the solution for pressure and velocity in the star Region ------------------------------*/

double *Newton_Raphson( double DR, double DL,double UR, double UL, double PL, double PR, double CL, double CR, double Tolerance ){

    double *UPM = new double [2];
    double P_star;
    double dU;
    double FL, FR;
    double FDL, FDR;
    double U_star;
    int NI = 0;
    double CHANGE;
    double P_Guess;

    P_Guess = P_M( DR, DL, UR, UL, PL, PR, CL, CR);

   // cout<<"inital Pressure guesss is \t"<<P_Guess<<endl;

    dU = UR-UL;
    //cout<<"Pressure left\t "<<PL<<"Pressure right\t"<<PR<<endl;

    //Compute Pressure

    do{

        Pressure_star( FL, FDL, DL, PL, CL, P_Guess );
        Pressure_star( FR, FDR, DR, PR, CR, P_Guess );

        // cout<< "(\t"<<"\t FL \t"<<FL <<"\t+\t"<<"FR\t"<< FR <<"\t+\t"<<"dU\t"<< dU<<"\t)\t"<<"\t / \t"<<"\t(\t"<<"FDL \t"<<FDL<<"\t + \t"<<"\tFDR\t" << FDR<<"\t)\t"<<endl;
        P_star = P_Guess - ( FL + FR + dU)/(FDL + FDR);
        CHANGE = 2.0 * abs((P_star - P_Guess)/(P_star + P_Guess));
        NI ++;
        // cout<<"Numer of iteration is \t"<<NI<<"\t"<<"Change in Pressure is \t"<< CHANGE<< "\t"<<endl;
        if ( P_star < 0.0){

            P_star = Tolerance;
        }
        P_Guess = P_star;

    } while ( CHANGE > Tolerance && NI <20 );

 //   cout<<"the new pressure is \t"<<P_star<<endl;

    //Compute Velocity

    U_star = 0.5 * ( UL + UR + FR - FL);

    //  cout<<"the new velocity is \t "<<U_star<<endl;

    UPM[0] = U_star;
    UPM[1] = P_star;

    return UPM;
}


/*----------------------------------------------------------------------------------------------------------------*/
/*                                                                                                                */
/*       To Sample the solution throughout the wave pattern. Pressure PM and velocity UM in the                   */
/*              Star Region are known. Sampling is performed in terms of the 'speed' S = X/T.                     */
/*                                          Sampled values are D, U, P                                            */
/*                                                                                                                */
/*----------------------------------------------------------------------------------------------------------------*/

double  *Primitive_varaible( double DR, double DL,double UR, double UL, double PL, double PR, double CL, double CR, double S, double *UPM) {

    double *DUP = new double [3];
    double UM= UPM[0];
    double PM= UPM[1];
    double SHL, SHR, SL, SR, STL, STR;
    double CML, CMR, PML, PMR;
    double C;

    if(S <= UM){

        //Sampling point lies to the left of the contact discontinuity
        if (PM <= PL){

            //left Rarefraction
            SHL = UL - CL;

            if (S <= SHL ){

                //Sampled point is left data state
            //    cerr<<"I left data state"<<endl;
                DUP[0] = DL;
                DUP[1] = UL;
                DUP[2] = PL;
            }
            else{

                CML = CL* pow((PM/PL), G1);
                STL = UM - CML;

                if (S > STL){

                    //Sampled point is Star Left state
                  //  cout<<"I am at rarefraction left star state "<<endl;

                    DUP[0] = DL*pow((PM/PL), (1.0/gam));
                    DUP[1] = UM;
                    DUP[2] = PM;
                  //  cout<<"PM"<<PM<<endl;
                   // cout<<"PL"<<PL<<endl;
                   // cout<<"density"<<DUP[0]<<endl;
                }
                else{

               //     cerr<<"I left fan"<<endl;
                    //Sampled point is inside left fan

                    C = G5*(CL + G7*(UL - S));
                    DUP[0] = DL* pow((C/CL), G4);
                    DUP[1] = G5*(CL + G7*UL + S);
                    DUP[2] = PL*pow((C/CL), G3);

                //    cerr<<"pressure being updated "<<DUP[2] <<"\t=\t"<< "\tPL\t"<<PL<<"\t*\t"<<"pow\t"<<"(\t"<<"\t(\t"<<"\tC\t"<<C<<"\t/\t"<<"CL"<<CL<<"\t)\t"<<"\t,\t"<<"\tG3\t"<< G3<<"\t)\t"<<endl;

                }
            }

        }

        //left shock

        else{

            PML = PM / PL;
            SL  = UL - CL * sqrt(G2 * PML + G1);

            if( S <= SL ){

                //Sampled point is left data state

                DUP[0] = DL;
                DUP[1] = UL;
                DUP[2] = PL;

            }
            else{

                // Sampled point is Star Left state
             //   cout<<"I am at shock left star state "<<endl;
                DUP[0] = DL*(PML + G6)/(PML * G6 + 1.0);
                DUP[1] = UM;
                DUP[2] = PM;

             //   cout<<"PM"<<PM<<endl;
               // cout<<"PL"<<PL<<endl;
             //   cout<<"density"<<DUP[0]<<endl;

            }
        }

    }

    //Sampling point lies to the right of the contact discontinuity
    else{

        if (PM > PR){

            //Right shock

            PMR = PM/PR;
            SR  = UR + CR * sqrt(G2 * PMR + G1);

            if ( S >= SR ){

                //Sample point is right data state

                DUP[0] = DR;
                DUP[1] = UR;
                DUP[2] = PR;

            }
            else{

                //Sampled point is Star Right state
            //    cout<<"I am at right right shock star state"<<endl;
                DUP[0] = DR * (PMR + G6)/(PMR * G6 + 1.0);
                DUP[1] = UM;
                DUP[2] = PM;
             //   cout<<"density"<<DUP[0]<<endl;
            }

        }

        else{

            //Right Rarefraction
            SHR = UR + CR;

            if (S >= SHR ){

                //Sampled point is right data state

                DUP[0] = DR;
                DUP[1] = UR;
                DUP[2] = PR;

            }
            else{

                CMR = CR * pow((PM/PR), G1);
                STR = UM + CMR;

                if (S <= STR ){

                    //Sampled point is Star Right state

                //    cout<<"I am at right reareraction star state"<<endl;
                    DUP[0] = DR * pow((PM/PR), (1.0/gam));
                    DUP[1] = UM;
                    DUP[2] = PM;

                }
                else{

                    //Sampled point is inside left fan

                    C = G5*(CR - G7*(UR - S));
                    DUP[0] = DR * pow((C/CR),G4);
                    DUP[1] = G5 * (-CR + G7*UR + S);
                    DUP[2] = PR * pow((C/CR), G3);
                }

            }

        }
    }

    return DUP;
}

/* ------------- inital condition and boundary condiitons  ----------- */

void initialConditions_ERS(int N, double dx, double *speed, double *density, double *pressure, double *energy){

    double EL = (PL/(DL * ( gam - 1.0)))+(UL * UL)/2.0 ;
    double ER = (PR/(DR * ( gam - 1.0)))+(UR * UR)/2.0 ;

    for (int i = 0; i < N; i++){

        double x=(i)*dx+dx/2.0;
/*
        if (x<x0){
            u[0][i] = DL;
            flux[0][i] = DL * UL;
        }
        else{
            u[0][i] = DR;
            flux[0][i] = DR * UR;
        }

        if (x<x0){
            u[1][i] = DL * UL;
            flux[1][i] = DL * UL * UL + PL ;
        }
        else{
            u[1][i] = DR * UR;
            flux[1][i] = DR * UR * UR + PR ;
        }

        if (x<x0){
            u[2][i] = DL * (EL);
            flux[2][i] = UL * (EL + PL);

        }
        else{
            u[2][i] = DR * (ER);
            flux[2][i] = UR * (ER + PR);

        }
*/

        if (x<x0){
            speed[i] = UL;
            density[i] = DL;
            pressure[i] = PL;
            energy[i]=EL;
        }
        else{
            speed[i] = UR;
            density[i] = DR;
            pressure[i] = PR;
            energy[i] = ER;
        }

    }

}

double **boundaryConditions(int N, double**u){

    double *u_extend = new double [(N+2)*3];
    double **U_extend = new double *[3];


    U_extend[0]= u_extend;

    U_extend[1] = u_extend + (N+2);

    U_extend[2] = u_extend  + (N+2) * 2;

    for (int i = 0; i<N; i++){

        U_extend[0][i+1]=u[0][i];

        U_extend[1][i+1]=u[1][i];

        U_extend[2][i+1]=u[2][i];

    }



    U_extend[0][0] = u[0][1];
    U_extend[0][N+2] = u[0][N-1];


    U_extend[1][0] = u[1][1];
    U_extend[1][N+2] = u[1][N-1];


    U_extend[2][0] = u[2][1];
    U_extend[2][N+2] = u[2][N-1];


    return U_extend;
}


double *boundaryConditions2( double *Property){

    double *Property_extend = new double [(N+2)];

    for (int i = 0; i<N; i++){

        Property_extend[i+1] = Property[i];
    }

    Property_extend[0] = Property[1];
    Property_extend[N+2] = Property[N-1];


    return Property_extend;
}

/* ----------This follwowing function allows you to print results on screen -------- */
void Display_ERS ( double *data,double *data2,double *data3, double *data4,int N){


    cout<<"\n"<<endl;

    for (int i=0;i<N;i++){

        cout<<data[i]<<"\t";
    }

    cout<<"\n"<<endl;

    for (int i=0;i<N;i++){

        cout<<data2[i]<<"\t";
    }

    cout<<"\n"<<endl;

    for (int i=0;i<N;i++){

        cout<<data3[i]<<"\t";
    }

    cout<<"\n"<<endl;

    for (int i=0;i<N;i++){

        cout<<data4[i]<<"\t";
    }

    cout<<"\n"<<endl;
}


//<double>( *FiniteDifferenceSolver)(int, vector<double>, double, double, double);
//switch()

//Claim plotfile from fstream and get ready for output
fstream plotfile;


int main(void){


    double dx = L/N;

    double *uspeed = new double[N];
    double *density = new double[N];
    double *pressure = new double[N];
    double *energy = new double[N];
    double *internal_energy = new double[N];

    initialConditions_ERS(N, dx, uspeed,density , pressure, energy);

    double *uspeed_extend ;
    double *density_extend ;
    double *pressure_extend ;
    double *energy_extend ;

    double t=0;
    double dt ;

    double XPOS ;
    double S ;

    double *UPM_temp ;


    Display_ERS( uspeed, density, pressure, energy,N);

    uspeed_extend = boundaryConditions2(uspeed);

    density_extend = boundaryConditions2(density);

    pressure_extend = boundaryConditions2(pressure);

    energy_extend = boundaryConditions2(energy);

    //  dt =dt_func(dx, uspeed_extend, pressure_extend, density_extend);
    for (int i = 0; i<N ; i++ ){

        if (pressure_extend[i] != pressure_extend[i+1] || density_extend[i] != density_extend[i+1] || uspeed_extend[i] != uspeed_extend[i+1]){

            double CL = sqrt(gam * (pressure_extend[i]/density_extend[i]));
            double CR = sqrt(gam * (pressure_extend[i+1]/density_extend[i+1]));

            UPM_temp = Newton_Raphson( density_extend[i+1], density_extend[i], uspeed_extend[i+1], uspeed_extend[i], pressure_extend[i], pressure_extend[i+1], CL, CR, Tolerance);

            cout<<"Velocity is \t"<<UPM_temp[0]<<endl;
            cout<<"pressure is \t"<<UPM_temp[1]<<endl;

        }

    }


    for ( int i =0; i<N; i++){

        double *DUP_temp;
        double CL = sqrt(gam * (pressure_extend[i]/density_extend[i]));
        double CR = sqrt(gam * (pressure_extend[i+1]/density_extend[i+1]));

        //  cout<<"\tCL\t"<<CL<<endl;
        XPOS = (i-0.5) *dx;
        S = (XPOS -x0)/tStop;

           //cout<<" wave speed \t"<<S<<endl;
        DUP_temp = Primitive_varaible(density_extend[i+1], density_extend[i],uspeed_extend[i+1], uspeed_extend[i], pressure_extend[i], pressure_extend[i+1], CL, CR, S, UPM_temp);

        density_extend[i+1]= DUP_temp [0];
        uspeed_extend[i+1] = DUP_temp [1];
        pressure_extend[i+1] = DUP_temp [2];

    }

    for (int i =0; i<N;i++){

        density[i]= density_extend[i+1];
        uspeed[i]= uspeed_extend[i+1];
        pressure[i]= pressure_extend[i+1];
	
    }

    for (int i =0 ; i<N;i++){

        internal_energy [i] = pressure[i]/(density[i]*(gam -1));
    }


    Display_ERS( uspeed, density, pressure, energy,N);

    plotfile.open("plotExact_Riemann_SolverToroTest1.dat", fstream::out);

    if(plotfile.fail()){

        cout<<"Error opening file"<<endl;
        exit(0);
    }

    for (int i=0;i<N;i++){

        double x=(i)*dx;

        plotfile<<x<<"\t"<<uspeed[i]<<"\t"<<density[i]<<"\t"<<pressure[i]<<"\t"<<internal_energy[i]<<"\t"<< phi[i]<<endl;
    }



    delete[] uspeed;
    delete[] density;
    delete[] pressure;
    delete[] energy;
    delete[] uspeed_extend;
    delete[] density_extend;
    delete[] pressure_extend;
    delete[] energy_extend;



    return 0;


}









